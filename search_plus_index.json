{"./":{"url":"./","title":"About HepLib","keywords":"","body":"HepLib HepLib is a C++ library for computations in High Energy Physics with the help of GiNaC language which is a C++ library used to perform symbolic computations. HepLib combines several well-known packages to get high efficiency, including Fermat to perform multivariate polynomial simplification, matrix operators, ... FORM to perform Dirac and Color matrix related computations, polynomial factorization, ... Qgraf to generate the Feynman aptitudes/diagrams. FIRE or KIRA for the IBP reduction. Another core feature of HepLib is the numerical evaluation of Master Integrals using Sector Decomposition with a customizable numerical integrator including the arbitrary precision supported by MPFR. Reference: https://doi.org/10.1016/j.cpc.2021.107982 "},"installation.html":{"url":"installation.html","title":"Installation","keywords":"","body":"How to Install HepLib Download and extract the all-in-one archive wget https://heplib.github.io/download/Install.tar.gz tar xfv Install.tar.gz Install using install.sh cd Install INSTALL_PATH= jn=8 ./install.sh Try a simple example Prepare a C++ file named trace.cpp with the following content #include \"HepLib.h\" using namespace HepLib; int main(int argc, char** argv) { Index mu(\"mu\"), nu(\"nu\"); Vector p1(\"p1\"), p2(\"p2\"); Symbol m(\"m\"); //note GAS(1) in gline, corresponds to the identity matrix ex gline = GAS(p1)*GAS(mu)*(GAS(p2)+m*GAS(1))*GAS(mu); ex trace = form(TR(gline)); cout Compile trace.cpp using heplib++ from HepLib INSTALL_PATH/bin/heplib++ -o trace trace.cpp Run trace to get the trace for Tr[γ⋅p1 γμ (γ⋅p2+m) γμ] ./trace # -4*d*p2.p1+8*p2.p1 "},"usage-in-c++.html":{"url":"usage-in-c++.html","title":"Usage in C++","keywords":"","body":"Usage in C++ The usage of HepLib is similar to other C++ library by including the proper header files in the C++ source code, compiling the program and linking with HepLib and other necessary libraries. 1. Prepare the C++ Code #include \"HepLib.h\" using namespace HepLib; using namespace FC; int main(int argc, char** argv) { Index mu(\"mu\"), nu(\"nu\"); Vector p1(\"p1\"), p2(\"p2\"); Symbol m(\"m\"); //note GAS(1) in gline, corresponds to the identity matrix ex gline = GAS(p1)*GAS(mu)*(GAS(p2)+m*GAS(1))*GAS(mu); ex trace = form(TR(gline)); hout The above code trace.cpp shows how to perform the D-dimensional trace on a Dirac-&#x1D6FE; chain: Tr[γ.p1γμ(γ.p2+m)γμ] 2. Compile and Run One can compile the trace.cpp using heplib++ and run it as follows: /bin/heplib++ -o trace trace.cpp ./trace # 8*p2.p1+(-4)*D*p2.p1 "},"objects-in-c++.html":{"url":"objects-in-c++.html","title":"Objects in C++","keywords":"","body":"Usage in C++ Object Example Description Symbol Symbol(\"s\") a real variable s. Index Index(\"mu\",Type::VD) a Lorentz index mu with dimension D. Index(\"mu\",Type::CA) a color index a with dimension NA. Index(\"mu\",Type::CF) a color index i with dimension NF. Vector Vector(\"p\") a vector/momentum p. Pair Pair(mu,nu) a Kronecker delta δμν with Index mu and nu. Pair(p,mu) a Vector p with Lorentz Index mu, pμ, p.mu. Pair(p,q) a scalar product p⋅q between Vector p and q. SUNT SUNT(a,i,j) a T-matrix element Taij for SU(N) group. SUNT(lst{a,b,c},i,j) a matrix element of a product of T, (TaTbTc)ij. SUNF SUNF(a,b,c) a structure constant fabc of SU(N) group. SUNF4 SUNF4(a,b,c,d) a contract of two SUNF, fabefecd. Eps Eps(mu1,mu2,mu3,mu4) a Levi-Civita tensor εμ1μ2μ3μ4. Eps(p1,p2,mu1,mu2) a partially contracted Levi-Civita tensor εp1p2μ1μ2. Eps(p1,p2,p3,p4) a fully contracted Levi-Civita tensor εp1p2p3p4. DGamma DGamma(mu,l) a Dirac-γ matrix γμ for a fermion line l. DGamma(p,l) a Dirac slash p/=pμγν for a fermion line l. DGamma(1/5/6/7,l) a unit matrix, γ5, γ6, γ7 for a fermion line l. SP SP(mu,nu) evaluated to δμν. SP(p+s*q,mu) evaluated to pμ+sqμ. SP(2*p+q,p+s*q) evaluated to 2p2+(2s+1)p⋅q+sq2. GAS GAS(mu) evaluated to γμ. GAS(3*p+s*q) evaluated to 3p/+sq/. GAS(1/5/6/7) evaluated to a unit matrix, γ5, γ6, γ7, respectively. LC LC(p,mu,p+s*q,k) evaluated to sεkphμ. TR TR(expr) a wrapper for the Dirac trace of expression expr. TTR TTR(lst{a,b,c,d}) a wraaper for the SU(N) trace of TaTbTcTd. form form(expr) evaluate the expression expr using FORM program. "},"examples-in-c++.html":{"url":"examples-in-c++.html","title":"Examples in C++","keywords":"","body":"Examples in C++ Please have a look at Usage in C++ for compiling a .cpp to an executable program. One can also try those examples at Try & Run online Examples @ Basic Examples @ Hep Examples @ SD "},"usage-in-python.html":{"url":"usage-in-python.html","title":"Usage in Python","keywords":"","body":"Usage in Python HepLib provides a wrapper class HepLibW as an interface to other languages, the SWIG interace file HepLib.i is also installed /include/HepLib.i. We will just show the usage within python, but it also applys to other languages with the help of SWIG. Compile the python module One can use the following makefile to generate the python module files: _HepLib.so and HepLib.py. python 3.x(>3.8)python 3.8all: _HepLib.so HLS=HepLib_SWIG flatns=\"\" uname := $(shell uname -s) ifeq ($(uname),Darwin) flatns = \"-flat_namespace\" endif $(HLS).cpp: swig -python -c++ -o $(HLS).cpp {% math %}(heplib-config --prefix)/include/HepLib.i $(HLS).o : $(HLS).cpp heplib++ -fPIC -c $(HLS).cpp {% endmath %}(python3-config --cflags) _HepLib.so : $(HLS).o heplib++ -shared $(flatns) $(HLS).o -o _HepLib.so {% math %}(python3-config --ldflags --embed) clean: rm -f $(HLS)* _HepLib.so HepLib.py all: _HepLib.so HLS=HepLib_SWIG flatns=\"\" uname := $(shell uname -s) ifeq ($(uname),Darwin) flatns = \"-flat_namespace\" endif $(HLS).cpp: swig -python -c++ -o $(HLS).cpp {% endmath %}(heplib-config --prefix)/include/HepLib.i $(HLS).o : $(HLS).cpp heplib++ -fPIC -c $(HLS).cpp {% math %}(python3-config --cflags) _HepLib.so : $(HLS).o heplib++ -shared $(flatns) $(HLS).o -o _HepLib.so {% endmath %}(python3-config --ldflags) -lpython3.8 clean: rm -f $(HLS)* _HepLib.so HepLib.py Python version for various C++ codes Note: the various .cpp files are introduced in Reference: https://doi.org/10.1016/j.cpc.2021.107982 0.py (python version for 0.cpp) #!/usr/bin/env python3 # python version for 0.cpp from HepLib import * x = symbol(\"x\") y = symbol(\"y\") z = symbol(\"z\") r = expr(\"2/3\") print(\"x ->\", x, \", r ->\", r) e1 = r*x+2*y+pow(y,10) print(\"e1 ->\", e1) e2 = (x+1)/(x-1) print(\"e2 ->\", e2) e3 = sin(x+2*y)+3*z+41 print(\"e3 ->\", e3) e4 = e3+e2/exp(e1) print(\"e4 ->\", e4) print() x = symbol(\"x\") y = Symbol(\"y\") print(\"x ->\", x, \", y->\", y) e1 = conjugate(x) print(\"conjugate(x) ->\", e1) e2 = conjugate(y) print(\"conjugate(y) ->\", e2) print() 1.py (python version for 1.cpp) #!/usr/bin/env python3 # python version for 0.cpp from HepLib import * expr_str = \"WF(1)+x(1)^2+sin(5)+power(a,n)\" e1 = expr(expr_str) print(e1) a = Symbol(\"a\") n = Symbol(\"n\") e2 = WF(expr(1))+pow(x(1),2)+sin(expr(5))+pow(a,n) print(e1-e2) print() 2.py (python version for2.cpp) #!/usr/bin/env python3 # python version for 0.cpp from HepLib import * x = Symbol(\"x\") y = Symbol(\"y\") z = Symbol(\"z\") n = Symbol(\"n\") l1 = lst([x, y, x+z]) e1 = pow(sin(x),n) print(\"l1 ->\", l1) print(\"e1 ->\", e1) tot = l1.nops() print(\"l1.nops() ->\", tot) item1 = l1.op(0) print(\"1st item of l1 ->\", item1) l1.let_op(2, e1) print(\"updated l1 ->\", l1) tot = e1.nops() print(\"e1.nops() ->\", tot) item2 = e1.op(1) print(\"2nd item of e1 ->\", item2) print() 3.py (python version for3.cpp) #!/usr/bin/env python3 # python version for 0.cpp from HepLib import * x = Symbol(\"x\") y = Symbol(\"y\") e0 = expr(\"x^4+x^3+x^2+x\") print(\"e0 ->\", e0) e1 = e0.subs([pow(x,w)>>pow(y,w+2)]) print(\"e1 ->\",e1) class mapClass(MapFunction): def map(self, e): if(e.match(pow(x,w)) and e.op(1).info(\"even\")): return pow(y,e.op(1)+2) else: return e.map(self) e2 = mapClass()(e0) print(\"e2 ->\",e2) print() 4.py (python version for4.cpp) #!/usr/bin/env python3 # python version for 0.cpp from HepLib import * x = Symbol(\"x\") y = Symbol(\"y\") data = exvec() total = 100 for i in range(total): data.push_back(sin(exp(x+y*i))) class ParFunRun(ParFun): def __call__(self, idx): ret = data[idx] ret = series(ret,x,5) #print(\"idx:\", idx) return ret f = ParFunRun() set_Verbose(100) set_Parallel_Process(4) ret = Parallel(total, f) #print(ret) 5.py (python version for5.cpp) #!/usr/bin/env python3 # python version for 0.cpp from HepLib import * me = Symbol(\"me\") mm = Symbol(\"mm\") e = Symbol(\"e\") mu = Index(\"mu\") nu = Index(\"nu\") p = Vector(\"p\") P = Vector(\"P\") k = Vector(\"k\") K = Vector(\"K\") q = Vector(\"q\") letSP(p,me*me) letSP(P,me*me) letSP(k,mm*mm) letSP(K,mm*mm) def gpm(p, m): return GAS(p)+m*GAS(1) tr1 = TR( gpm(P,-me)*GAS(mu)*gpm(p,me)*GAS(nu) ); tr2 = TR( gpm(k,mm)*GAS(mu)*gpm(K,-mm)*GAS(nu) ); res = pow(e,4) / (4*pow(SP(q),2)) * tr1 * tr2; set_form_using_dim4(True) res = form(res) res = factor(res); print(res.subs(me>>0)); print() set_form_using_su3(True) a = IndexCA(\"a\") i = IndexCF(\"i\") j = IndexCF(\"j\"); tr = TTR([a,a]); print(\"tr1 =\", form(tr)) tr = SUNT(a,i,j) * SUNT(a,j,i); print(\"tr2 =\", form(tr)) tr = SUNT([a,a],i,i) print(\"tr3 =\", form(tr)) print() 6.py (python version for6.cpp) #!/usr/bin/env python3 from HepLib import * A = Symbol(\"A\") e = Symbol(\"e\") ebar = Symbol(\"ebar\") mu = Symbol(\"mu\") mubar = Symbol(\"mubar\") p = Vector(\"p\") P = Vector(\"P\") k = Vector(\"k\") K = Vector(\"K\") me = Symbol(\"me\") mm = Symbol(\"mm\") proc = Process() proc.Model = \"\"\" [e, ebar, -] [mu, mubar, -] [A, A, +] [ebar, e, A] [mubar, mu, A] \"\"\" proc.In = \"e[p],ebar[P]\" proc.Out = \"mubar[k],mu[K]\" proc.Options = \"onshell\" proc.Loops = 0 st = {} st[\"p\"] = p st[\"P\"] = P st[\"k\"] = k st[\"K\"] = K amps = proc.Amplitudes(st) set_InOutTeX(-1,\"$e^-(p)$\") set_InOutTeX(-3,\"$e^+(P)$\") set_InOutTeX(-2,\"$\\\\mu^+(k)$\") set_InOutTeX(-4,\"$\\\\mu^-(K)$\") set_LineTeX(Symbol(\"e\"),\"fermion, edge label=$e$\") set_LineTeX(Symbol(\"ebar\"),\"anti fermion, edge label=$e$\") set_LineTeX(Symbol(\"mu\"),\"fermion, edge label=$\\\\mu$\") set_LineTeX(Symbol(\"mbar\"),\"anti fermion, edge label=$\\\\mu$\") set_LineTeX(Symbol(\"A\"),\"photon, edge label=$\\\\gamma$\") Process.DrawPDF(amps, \"amps.pdf\") class ClassFR(MapFunction): def __init__(self): MapFunction.__init__(self) def map(self, e): if(isFunction(e,\"OutField\") or isFunction(e,\"InField\")): return expr(1) elif(isFunction(e, \"Propagator\")): fi1 = e.op(0).op(1) fi2 = e.op(1).op(1) mom = e.op(2) if(e.op(0).op(0)==A): return (-I) * SP(LI(fi1),LI(fi2)) / SP(mom); # Feynman Gauge elif(e.op(0).op(0)==ebar): return I * Matrix(GAS(mom)+GAS(1)*me, DI(fi1),DI(fi2)) / (SP(mom)-me*me) elif(e.op(0).op(0)==mubar): return I * Matrix(GAS(mom)+GAS(1)*mm, DI(fi1),DI(fi2)) / (SP(mom)-mm*mm) elif(isFunction(e, \"Vertex\")): fi1 = e.op(0).op(1) fi2 = e.op(1).op(1) fi3 = e.op(2).op(1) if(e.op(0).op(0)==ebar): return I*Symbol(\"e\")*Matrix(GAS(LI(fi3)),DI(fi1),DI(fi2)) elif(e.op(0).op(0)==mubar): return I*Symbol(\"e\")*Matrix(GAS(LI(fi3)),DI(fi1),DI(fi2)) else: return e.map(self) amps_FR = ClassFR()(amps[0]) print(\"amps_FR: \") print(amps_FR); ampL = amps_FR ampR = IndexL2R(conjugate(ampL)); def SS1(p,m,i): return Matrix(GAS(p)+m*GAS(1),DI(i),RDI(i)) def SS2(p,m,i): return Matrix(GAS(p)+m*GAS(1),RDI(i),DI(i)) M2 = ampL * ampR * SS1(p,me,-1) * SS2(P,-me,-3) * SS1(k,-mm,-2) * SS2(K,mm,-4); M2 = MatrixContract(M2); print(\"M2: \") print(M2) print() set_form_using_dim4(True) letSP(p,me*me) letSP(P,me*me) letSP(k,mm*mm) letSP(K,mm*mm) res = form(M2); print(\"Final M2:\") print(factor(res.subs(me>>0))) 7.py (python version for7.cpp) #!/usr/bin/env python3 from HepLib import * p = Vector(\"p\") q1 = Vector(\"q1\") expr = expr(1)/SP(q1) * expr(1)/(2*SP(p,q1)-SP(q1)) * expr(1)/(2*SP(p,q1)+SP(q1)) r = Apart(expr,[q1],[p]); r1 = ApartIR2ex(r); r2 = ApartIR2F(r); print(r) print() print(r1) print() print(r2) print() r3 = Apart(expr, [SP(q1),SP(p,q1)]) print(r3) print() 8.py (python version for8.cpp) #!/usr/bin/env python3 import os from HepLib import * q1 = Symbol(\"q1\") p = Symbol(\"p\") m = Symbol(\"m\") fire = FIRE() fire.Internal = exvec([ q1 ]) fire.External = exvec([ p ]) fire.Replacements = exvec([ p*p >> m*m ]) fire.Propagators = exvec([ q1*q1, 2*p*q1-q1*q1 ]) fire.Integrals = exvec([ expr(\"{2,1}\") ]) fire.WorkingDir = \"IBPdir\"; fire.Reduce() print(\"Reduced Rules:\") print(fire.Rules) print(\"Master Integrals:\") print(fire.MIntegrals) os.system(\"rm -rf IBPdir\") 9.py (python version for9.cpp) #!/usr/bin/env python3 import os from HepLib import * k = Symbol(\"k\") r = Symbol(\"r\") q = Symbol(\"q\") p1 = Symbol(\"p1\") p2 = Symbol(\"p2\") s = Symbol(\"s\") fp = FeynmanParameter() fp.LoopMomenta = exvec([k,r,q]); fp.Propagators= exvec([ -pow(k,2),-pow(k+p1+p2,2),-pow(-k+r,2),-pow(p1+r,2),-pow(k-q,2),-pow(p1+q,2) ]); fp.Exponents = exvec(expr(\"{1+3*ep,1,1,1,1,1}\")) fp.lReplacements[p1*p1] = expr(0) fp.lReplacements[p2*p2] = expr(0) fp.lReplacements[p2*p1] = s/2 fp.lReplacements[s] = expr(-1) fp.Prefactor = pow(I*pow(Pi,2-ep),-3) * pow(tgamma(1-ep),3) work = SecDec() set_Verbose(100) work.Evaluate(fp) print(\"Final Result & Error:\") print(work.VE) "},"objects-in-python.html":{"url":"objects-in-python.html","title":"Objects in Python","keywords":"","body":"Objects in Python Python Class: expr A Python wrapper class for the inner GiNaC::ex object _expr. expr(i) contructor from an integer i. expr(s) constructor from a string s. nops() return the _expr.nops(). op(i) return the _expr.op(i). let_op(i,e) update the inner ith item by _expr.let_op(i)=e. expand() return _expr.expand(). normal() return _expr.normal(). factor() return _expr.factor(). series(s,o) return mma_series(_expr,s,o). subs(e) return _expr.subs(e). isSymbol() check the _expr is a Symbol. isVector() check the _expr is a Vector. isIndex() check the _expr is a Index. isPair() check the _expr is a Pair. isDGamma check the _expr is a DGamma. map(map_func) return the _expr.map(map_func), map_func is an object derived from MapFunction class. Python Functions expand(e) is equivalent to e.expand(). normal(e) is equivalent to e.normal(). factor(e) is equivalent to e.factor(). series(e,s,n) is equivalent to e.series(s,n). subs(e,es) is equivalent to e.subs(es). pow(e,n) return the power en. Symbol(s) return an expr object with _expr=HepLib::Symbol(s). Index(s) return an expr object with _expr=HepLib::FC::Index(s). Vector(s) return an expr object with _expr=HepLib::FC::Vector(s). SP(e1,e2) return an expr object with _expr=HepLib::FC::SP(e1._expr,e2._expr). GAS(e) return an expr object with _expr=HepLib::FC::GAS(e._expr). TR(e) return an expr object with _expr=HepLib::FC::TR(e._expr). form(e) return an expr object with _expr=HepLib::FC::form(e._expr). Python call any HepLib function call(func_str,e) return an expr object with _expr=func(e._expr). call(func_str,[e1,e2,...]) return an expr object with _expr=func(e1,e2,...). Python Class: Integral epN the requested ϵ order. epsN the requested ϵ′ order. verb the inner Verbose. Functions([e1,e2,...]) to assign the internal Functions or Propagators. Exponents([e1,e2,...]) to assign the internal Exponents. Evaluate() to evaluate the integral by Sector Decomposition, the Integral object itself holds the nummerical result. "},"examples-in-python.html":{"url":"examples-in-python.html","title":"Examples in Python","keywords":"","body":"Examples in Python "},"utils-in-heplib.html":{"url":"utils-in-heplib.html","title":"Utils in HepLib","keywords":"","body":"Utils in HepLib There are several useful utils installed to the directory /bin. heplib++ - HepLib g++ The basic uage: heplib++ -o prog prog.cpp The content in this script g++ -I'/include' -Wl,-rpath,. -Wl,-rpath,'/lib' -L'/lib' -lHepLib -lcln -lginac -lMinuit2 -lcubaq -lqhullstatic -lquadmath $@ -lHepLib -lcln -lginac -lMinuit2 -lcubaq -lqhullstatic -lquadmath heplib-config - parameters Genernal information of heplib-config from heplib-config --help Usage: heplib-config [--prefix|--cflags|--ldflags|--help] heplib-config --prefix to get the heplib-config --cflags to get the -I’/include’ heplib-config --ldflags to get the -Wl,-rpath,. -Wl,-rpath,’/lib’ -L’/lib’ sc - Server / Clients Genernal information of sc from sc --help A simple Server/Client, bypass with [i].log Supported Options: --total: total elements @server. --port: server port @server/@client. --server: server ip or hostname @client. --command: command with [i] replaced @client. --round: round to be cycled @server. One can run the following command on the master node sc --total 100 --port 1234 One will get the message as follows: Started @ 2020-11-17 16:05:27 Server Port: 1234 Server: 0 / 99 @ 16:05:2 The server is ready to dispatch item (from 0 to 99) to the connected slave node. Now one can run the following command on each slave node sc --server master-node-host --port 1234 --command \"echo [i]\" one will see the slave node will repleatly get the item from the server, and exceute the command echo [i], note that [i] will replaced by the actual index (form 0 to 99). Note that to prevent the command to run multiple times on the same [i], one can generate a [i].log from the command, e.g., sc --server master-node-host --port 1234 --command \"echo [i] > [i].log\" sc will skip the item [i] when there is a file named [i].log. "},"try-and-run-online.html":{"url":"try-and-run-online.html","title":"Try & Run online","keywords":"","body":"Try & Run online One can try the HepLib online. A cloud machine One can try and run HepLib on a small private cloud machine with the help of webssh. HepLib @ replit One can also open @heplib and click the Run button, after the initialization of HepLib, one will get the information to compile codes/trace.cpp or the python interface. "}}