{"./":{"url":"./","title":"About HepLib","keywords":"","body":"HepLib HepLib is a C++ library for computations in High Energy Physics with the help of GiNaC language which is a C++ library used to perform symbolic computations. HepLib combines several well-known packages to get high efficiency, including Fermat to perform multivariate polynomial simplification, matrix operators, ... FORM to perform Dirac and Color matrix related computations, polynomial factorization, ... Qgraf to generate the Feynman aptitudes/diagrams. FIRE or KIRA for the IBP reduction. Another core feature of HepLib is the numerical evaluation of Master Integrals using Sector Decomposition with a customizable numerical integrator including the arbitrary precision supported by MPFR. Reference: https://doi.org/10.1016/j.cpc.2021.107982 "},"installation.html":{"url":"installation.html","title":"Installation","keywords":"","body":"How to Install HepLib Download and extract the all-in-one archive wget https://heplib.github.io/download/Install.tar.gz tar xfv Install.tar.gz Install using install.sh cd Install INSTALL_PATH= jn=8 ./install.sh Try a simple example Prepare a C++ file named trace.cpp with the following content #include \"HepLib.h\" using namespace HepLib; int main(int argc, char** argv) { Index mu(\"mu\"), nu(\"nu\"); Vector p1(\"p1\"), p2(\"p2\"); Symbol m(\"m\"); //note GAS(1) in gline, corresponds to the identity matrix ex gline = GAS(p1)*GAS(mu)*(GAS(p2)+m*GAS(1))*GAS(mu); ex trace = form(TR(gline)); cout Compile trace.cpp using heplib++ from HepLib INSTALL_PATH/bin/heplib++ -o trace trace.cpp Run trace to get the trace for Tr[γ⋅p1 γμ (γ⋅p2+m) γμ] ./trace # -4*d*p2.p1+8*p2.p1 "},"usage-in-c++.html":{"url":"usage-in-c++.html","title":"Usage in C++","keywords":"","body":"Usage in C++ The usage of HepLib is similar to other C++ library by including the proper header files in the C++ source code, compiling the program and linking with HepLib and other necessary libraries. 1. Prepare the C++ Code #include \"HepLib.h\" using namespace HepLib; using namespace FC; int main(int argc, char** argv) { Index mu(\"mu\"), nu(\"nu\"); Vector p1(\"p1\"), p2(\"p2\"); Symbol m(\"m\"); //note GAS(1) in gline, corresponds to the identity matrix ex gline = GAS(p1)*GAS(mu)*(GAS(p2)+m*GAS(1))*GAS(mu); ex trace = form(TR(gline)); hout The above code trace.cpp shows how to perform the D-dimensional trace on a Dirac-&#x1D6FE; chain: Tr[γ.p1γμ(γ.p2+m)γμ] 2. Compile and Run One can compile the trace.cpp using heplib++ and run it as follows: /bin/heplib++ -o trace trace.cpp ./trace # 8*p2.p1+(-4)*D*p2.p1 "},"objects-in-c++.html":{"url":"objects-in-c++.html","title":"Objects in C++","keywords":"","body":"Usage in C++ Object Example Description Symbol Symbol(\"s\") a real variable s. Index Index(\"mu\",Type::VD) a Lorentz index mu with dimension d. Index(\"mu\",Type::CA) a color index a with dimension NA. Index(\"mu\",Type::CF) a color index i with dimension NF. Vector Vector(\"p\") a vector/momentum p. Pair Pair(mu,nu) a Kronecker delta δμν with Index mu and nu. Pair(p,mu) a Vector p with Lorentz Index mu, pμ, p.mu. Pair(p,q) a scalar product p⋅q between Vector p and q. SUNT SUNT(a,i,j) a T-matrix element Taij for SU(N) group. SUNT(lst{a,b,c},i,j) a matrix element of a product of T, (TaTbTc)ij. SUNF SUNF(a,b,c) a structure constant fabc of SU(N) group. SUNF4 SUNF4(a,b,c,d) a contract of two SUNF, fabefecd. Eps Eps(mu1,mu2,mu3,mu4) a Levi-Civita tensor εμ1μ2μ3μ4. Eps(p1,p2,mu1,mu2) a partially contracted Levi-Civita tensor εp1p2μ1μ2. Eps(p1,p2,p3,p4) a fully contracted Levi-Civita tensor εp1p2p3p4. DGamma DGamma(mu,l) a Dirac-γ matrix γμ for a fermion line l. DGamma(p,l) a Dirac slash p/=pμγν for a fermion line l. DGamma(1/5/6/7,l) a unit matrix, γ5, γ6, γ7 for a fermion line l. SP SP(mu,nu) evaluated to δμν. SP(p+s*q,mu) evaluated to pμ+sqμ. SP(2*p+q,p+s*q) evaluated to 2p2+(2s+1)p⋅q+sq2. GAS GAS(mu) evaluated to γμ. GAS(3*p+s*q) evaluated to 3p/+sq/. GAS(1/5/6/7) evaluated to a unit matrix, γ5, γ6, γ7, respectively. LC LC(p,mu,p+s*q,k) evaluated to sεkphμ. TR TR(expr) a wrapper for the Dirac trace of expression expr. TTR TTR(lst{a,b,c,d}) a wraaper for the SU(N) trace of TaTbTcTd. form form(expr) evaluate the expression expr using FORM program. "},"examples-in-c++.html":{"url":"examples-in-c++.html","title":"Examples in C++","keywords":"","body":" [!TIP] Please have a look at Usage in C++ for compiling a .cpp to an executable program. Examples @ High Energy Physics Basic usage of Vector, DiracGamma and SUNT running with FORM program: form.cpp Basic usage of color objects including SUNT, SUNF still with FORM program: color.cpp A complete example to use qgraf program: qgraf.cpp An example to show the Tensor Index Reduction: TIR.cpp An example to show the Partial Fractions: apart.cpp Basic usage of the interface to FIRE program: fire.cpp Examples @ Section Decomposition An example to use the numerical integrator HCubature: hcubature.cpp An example from SecDec program: t0.cpp An modified example of t0.cpp: t1.cpp An example form SDExpand in FIESTA package: exp1.cpp An example to expand a generic parameter integral: exp2.cpp Examples to show the usage of ChengWu method: cw.cpp Examples to show the usage of KillPowers similar to FIESTA package: kp.cpp An example to evaluate the Master Integral from Fragmentation Functions: mi_ff.cpp "},"utils-in-heplib.html":{"url":"utils-in-heplib.html","title":"Utils in HepLib","keywords":"","body":"Utils in HepLib There are several useful utils installed to the directory /bin. heplib++ - HepLib g++ The basic uage: heplib++ -o prog prog.cpp sc - Server / Clients Genernal information of sc from sc --help A simple Server/Client, bypass with [i].log Supported Options: --total: total elements @server. --port: server port @server/@client. --server: server ip or hostname @client. --command: command with [i] replaced @client. --round: round to be cycled @server. One can run the following command on the master node sc --total 100 --port 1234 One will get the message as follows: Started @ 2020-11-17 16:05:27 Server Port: 1234 Server: 0 / 99 @ 16:05:2 The server is ready to dispatch item (from 0 to 99) to the connected slave node. Now one can run the following command on each slave node sc --server master-node-host --port 1234 --command \"echo [i]\" one will see the slave node will repleatly get the item from the server, and exceute the command echo [i], note that [i] will replaced by the actual index (form 0 to 99). Note that to prevent the command to run multiple times on the same [i], one can generate a [i].log from the command, e.g., sc --server master-node-host --port 1234 --command \"echo [i] > [i].log\" sc will skip the item [i] when there is a file named [i].log. "},"try-and-run-online.html":{"url":"try-and-run-online.html","title":"Try & Run online","keywords":"","body":"Try & Run HepLib @ replit One can also open @heplib and click the Run button, after the initialization of HepLib, one will get the information to compile codes/trace.cpp or the python interface. "}}